const { Router } = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const { PrismaClient } = require('@prisma/client');
const { authenticateToken } = require('../middleware/auth');
const { requireMaterialUpload, requireTeacherOrHead } = require('../middleware/roles');
const { uploadToLocal, getLocalFilePath, deleteLocalFile, STORAGE_TYPE, isS3Configured } = require('../utils/s3Storage.js');

// Define AuthRequest interface locally since we can't import types in CommonJS
interface AuthRequest extends Express.Request {
    user?: {
      id: string;
      email: string;
      name: string;
      role: string;
    };
    params?: any;
    body?: any;
}

const router = Router();
const prisma = new PrismaClient();

// Configure multer for file uploads
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../../uploads');
    // Ensure uploads directory exists
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

const upload = multer({
  storage,
  limits: {
    fileSize: 100 * 1024 * 1024 // 100MB limit
  },
  fileFilter: (req, file, cb) => {
    // Allow various file types for study materials
    const allowedTypes = [
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'application/vnd.ms-powerpoint',
      'application/vnd.openxmlformats-officedocument.presentationml.presentation',
      'application/vnd.ms-excel',
      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
      'video/mp4',
      'video/avi',
      'video/mov',
      'video/wmv',
      'image/jpeg',
      'image/png',
      'image/gif',
      'text/plain'
    ];

    if (allowedTypes.includes(file.mimetype)) {
      cb(null, true);
    } else {
      cb(new Error('Invalid file type'), false);
    }
  }
});

// Get all materials for a course
router.get('/course/:courseId', authenticateToken, async (req, res) => {
  try {
    const { courseId } = req.params;

    const materials = await prisma.material.findMany({
      where: { courseId },
      include: {
        course: {
          select: {
            id: true,
            title: true
          }
        }
      },
      orderBy: {
        createdAt: 'desc'
      }
    });

    res.json({ materials });
  } catch (error) {
    console.error('Get materials error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get material by ID
router.get('/:id', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const material = await prisma.material.findUnique({
      where: { id }
    });

    if (!material) {
      return res.status(404).json({ error: 'Material not found' });
    }

    res.json({ material });
  } catch (error) {
    console.error('Get material error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Upload material - Admin, Teacher, Management only
router.post('/', authenticateToken, requireMaterialUpload, upload.single('file'), async (req: AuthRequest, res) => {
  try {
    if (!req.user) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    const { courseId, title, type } = req.body;
    const file = req.file;

    // Validate input
    if (!courseId || !title || !type) {
      return res.status(400).json({ error: 'Course ID, title, and type are required' });
    }

    if (!file) {
      return res.status(400).json({ error: 'File is required' });
    }

    // Check if course exists
    const course = await prisma.course.findUnique({
      where: { id: courseId }
    });

    if (!course) {
      return res.status(404).json({ error: 'Course not found' });
    }

    // Use the filename generated by multer
    const filePath = file.filename;

    // Create material record
    const material = await prisma.material.create({
      data: {
        courseId,
        title,
        type,
        filePath: filePath,
        uploadedBy: req.user.id
      }
    });

    res.status(201).json({
      message: 'Material uploaded successfully',
      material
    });
  } catch (error) {
    console.error('Upload material error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Update material - Staff only (teachers can update materials for their own courses)
router.put('/:id', authenticateToken, requireTeacherOrHead, async (req: AuthRequest, res) => {
  try {
    const { id } = req.params;
    const { title, type } = req.body;

    // Check if material exists with course information
    const existingMaterial = await prisma.material.findUnique({
      where: { id },
      include: {
        course: {
          include: {
            teachers: {
              select: {
                id: true
              }
            }
          }
        }
      }
    });

    if (!existingMaterial) {
      return res.status(404).json({ error: 'Material not found' });
    }

    // Check if teacher has permission to update this material
    if (req.user.role === 'TEACHER') {
      const isTeacherOfCourse = existingMaterial.course.teachers.some(teacher => teacher.id === req.user.id);
      if (!isTeacherOfCourse) {
        return res.status(403).json({ error: 'You can only update materials for courses you teach' });
      }
    }

    // Prepare update data
    const updateData: any = {};
    if (title) updateData.title = title;
    if (type) updateData.type = type;

    // Update material
    const material = await prisma.material.update({
      where: { id },
      data: updateData
    });

    res.json({
      message: 'Material updated successfully',
      material
    });
  } catch (error) {
    console.error('Update material error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Delete material - Admin, Teacher, Management only
router.delete('/:id', authenticateToken, requireMaterialUpload, async (req, res) => {
  try {
    const { id } = req.params;

    // Check if material exists
    const existingMaterial = await prisma.material.findUnique({
      where: { id }
    });

    if (!existingMaterial) {
      return res.status(404).json({ error: 'Material not found' });
    }

    // Delete material record
    await prisma.material.delete({
      where: { id }
    });

    // Delete physical file based on storage type
    if (STORAGE_TYPE === 's3' && isS3Configured()) {
      // S3 Storage (commented out - uncomment when S3 is configured)
      /*
      try {
        await deleteFromS3(existingMaterial.filePath);
      } catch (error) {
        console.error('Failed to delete file from S3:', error);
        // Don't throw error to avoid breaking the deletion
      }
      */
    } else {
      // Local storage (current active method)
      try {
        deleteLocalFile(existingMaterial.filePath);
      } catch (error) {
        console.error('Failed to delete local file:', error);
        // Don't throw error to avoid breaking the deletion
      }
    }

    res.json({
      message: 'Material deleted successfully'
    });
  } catch (error) {
    console.error('Delete material error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Download material file
router.get('/:id/download', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const material = await prisma.material.findUnique({
      where: { id }
    });

    if (!material) {
      return res.status(404).json({ error: 'Material not found' });
    }

    if (STORAGE_TYPE === 's3' && isS3Configured()) {
      // S3 Storage (commented out - uncomment when S3 is configured)
      /*
      try {
        const signedUrl = await getSignedUrlForFile(material.filePath);
        res.redirect(signedUrl);
      } catch (error) {
        console.error('S3 signed URL error:', error);
        res.status(500).json({ error: 'Failed to generate download link' });
      }
      */
      // For now, fall back to local storage
      const filePath = getLocalFilePath(material.filePath);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
      }
      res.setHeader('Content-Disposition', `attachment; filename="${material.title}"`);
      res.setHeader('Content-Type', 'application/octet-stream');
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    } else {
      // Local storage (current active method)
      const filePath = getLocalFilePath(material.filePath);

      // Check if file exists
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
      }

      // Set appropriate headers
      res.setHeader('Content-Disposition', `attachment; filename="${material.title}"`);
      res.setHeader('Content-Type', 'application/octet-stream');

      // Stream the file
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    }

  } catch (error) {
    console.error('Download material error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// View material file inline (for PDFs and other viewable files)
router.get('/:id/view', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const material = await prisma.material.findUnique({
      where: { id }
    });

    if (!material) {
      return res.status(404).json({ error: 'Material not found' });
    }

    if (STORAGE_TYPE === 's3' && isS3Configured()) {
      // S3 Storage (commented out - uncomment when S3 is configured)
      /*
      try {
        const signedUrl = await getSignedUrlForFile(material.filePath);
        res.redirect(signedUrl);
      } catch (error) {
        console.error('S3 signed URL error:', error);
        res.status(500).json({ error: 'Failed to generate view link' });
      }
      */
      // For now, fall back to local storage
      const filePath = getLocalFilePath(material.filePath);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
      }

      // Get file extension to determine content type
      const ext = path.extname(material.filePath).toLowerCase();
      const contentType = getContentType(ext);

      res.setHeader('Content-Disposition', `inline; filename="${material.title}"`);
      res.setHeader('Content-Type', contentType);
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    } else {
      // Local storage (current active method)
      const filePath = getLocalFilePath(material.filePath);

      // Check if file exists
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'File not found' });
      }

      // Get file extension to determine content type
      const ext = path.extname(material.filePath).toLowerCase();
      const contentType = getContentType(ext);

      // Set appropriate headers for inline viewing
      res.setHeader('Content-Disposition', `inline; filename="${material.title}"`);
      res.setHeader('Content-Type', contentType);

      // Stream the file
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    }

  } catch (error) {
    console.error('View material error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Stream video material for viewing
router.get('/:id/stream', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;

    const material = await prisma.material.findUnique({
      where: { id }
    });

    if (!material) {
      return res.status(404).json({ error: 'Material not found' });
    }

    // Check if it's a video material
    const videoExtensions = ['.mp4', '.avi', '.mov', '.wmv', '.mkv', '.webm'];
    const fileExtension = path.extname(material.filePath).toLowerCase();

    if (!videoExtensions.includes(fileExtension)) {
      return res.status(400).json({ error: 'Material is not a video file' });
    }

    if (STORAGE_TYPE === 's3' && isS3Configured()) {
      // S3 Storage (commented out - uncomment when S3 is configured)
      /*
      try {
        const signedUrl = await getSignedUrlForFile(material.filePath);
        res.redirect(signedUrl);
      } catch (error) {
        console.error('S3 signed URL error:', error);
        res.status(500).json({ error: 'Failed to generate video stream link' });
      }
      */
      // For now, fall back to local storage
      const filePath = getLocalFilePath(material.filePath);
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'Video file not found' });
      }

      // Get file extension to determine content type
      const ext = path.extname(material.filePath).toLowerCase();
      const contentType = getVideoContentType(ext);

      res.setHeader('Content-Disposition', `inline; filename="${material.title}${ext}"`);
      res.setHeader('Content-Type', contentType);
      res.setHeader('Accept-Ranges', 'bytes');

      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    } else {
      // Local storage (current active method)
      const filePath = getLocalFilePath(material.filePath);

      // Check if file exists
      if (!fs.existsSync(filePath)) {
        return res.status(404).json({ error: 'Video file not found' });
      }

      // Get file extension to determine content type
      const ext = path.extname(material.filePath).toLowerCase();
      const contentType = getVideoContentType(ext);

      // Set appropriate headers for video streaming
      res.setHeader('Content-Disposition', `inline; filename="${material.title}${ext}"`);
      res.setHeader('Content-Type', contentType);
      res.setHeader('Accept-Ranges', 'bytes');

      // Stream the video file
      const fileStream = fs.createReadStream(filePath);
      fileStream.pipe(res);
    }

  } catch (error) {
    console.error('Stream material video error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get all materials and recordings for admin dashboard
router.get('/admin/all', authenticateToken, async (req, res) => {
  try {
    if (!req.user) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    // Check if user has admin/head/management role
    if (!['ADMIN', 'HEAD', 'MANAGEMENT'].includes(req.user.role)) {
      return res.status(403).json({ error: 'Access denied. Admin/Head/Management only.' });
    }

    const limit = req.query.limit ? parseInt(req.query.limit as string) : 50;

    // Get all materials with course information
    const materials = await prisma.material.findMany({
      take: limit,
      orderBy: {
        createdAt: 'desc'
      },
      include: {
        course: {
          select: {
            id: true,
            title: true,
            active: true
          }
        }
      }
    });

    // Separate materials and recordings
    const studyMaterials = materials.filter(m => m.type === 'STUDY_MATERIAL');
    const recordings = materials.filter(m => m.type === 'RECORDED_LECTURE');

    // Transform data for frontend
    const transformedMaterials = studyMaterials.map(material => ({
      id: material.id,
      title: material.title,
      type: 'PDF', // Default to PDF for study materials, could be enhanced to detect actual type
      uploadedBy: 'Unknown', // Since uploadedBy is just a string ID, we can't get the name without additional query
      date: material.createdAt.toISOString().split('T')[0],
      course: material.course.title,
      courseId: material.course.id,
      filePath: material.filePath
    }));

    const transformedRecordings = recordings.map(recording => ({
      id: recording.id,
      title: recording.title,
      instructor: 'Unknown', // Since uploadedBy is just a string ID, we can't get the name without additional query
      duration: '45 min', // Placeholder - could be enhanced with actual duration
      views: Math.floor(Math.random() * 100) + 10, // Placeholder - could track actual views
      date: recording.createdAt.toISOString().split('T')[0],
      course: recording.course.title,
      courseId: recording.course.id,
      filePath: recording.filePath
    }));

    res.json({
      materials: transformedMaterials,
      recordings: transformedRecordings,
      totalMaterials: studyMaterials.length,
      totalRecordings: recordings.length,
      totalItems: materials.length
    });
  } catch (error) {
    console.error('Get admin materials error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Get statistics for admin dashboard
router.get('/admin/stats', authenticateToken, async (req, res) => {
  try {
    if (!req.user) {
      return res.status(401).json({ error: 'User not authenticated' });
    }

    // Check if user has admin/head/management role
    if (!['ADMIN', 'HEAD', 'MANAGEMENT'].includes(req.user.role)) {
      return res.status(403).json({ error: 'Access denied. Admin/Head/Management only.' });
    }

    // Get material statistics
    const [
      totalMaterials,
      totalRecordings,
      recentMaterialsCount,
      recentRecordingsCount
    ] = await Promise.all([
      prisma.material.count({ where: { type: 'STUDY_MATERIAL' } }),
      prisma.material.count({ where: { type: 'RECORDED_LECTURE' } }),
      prisma.material.count({
        where: {
          type: 'STUDY_MATERIAL',
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
          }
        }
      }),
      prisma.material.count({
        where: {
          type: 'RECORDED_LECTURE',
          createdAt: {
            gte: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000) // Last 7 days
          }
        }
      })
    ]);

    res.json({
      stats: {
        totalMaterials,
        totalRecordings,
        totalContent: totalMaterials + totalRecordings,
        recentMaterialsCount,
        recentRecordingsCount,
        recentContentCount: recentMaterialsCount + recentRecordingsCount
      }
    });
  } catch (error) {
    console.error('Get admin material stats error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Helper function to get content type based on file extension
function getContentType(ext: string): string {
  const contentTypes: { [key: string]: string } = {
    '.pdf': 'application/pdf',
    '.doc': 'application/msword',
    '.docx': 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    '.ppt': 'application/vnd.ms-powerpoint',
    '.pptx': 'application/vnd.openxmlformats-officedocument.presentationml.presentation',
    '.xls': 'application/vnd.ms-excel',
    '.xlsx': 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    '.txt': 'text/plain',
    '.jpg': 'image/jpeg',
    '.jpeg': 'image/jpeg',
    '.png': 'image/png',
    '.gif': 'image/gif',
    '.mp4': 'video/mp4',
    '.avi': 'video/avi',
    '.mov': 'video/quicktime',
    '.wmv': 'video/x-ms-wmv'
  };

  return contentTypes[ext] || 'application/octet-stream';
}


module.exports = router;